Natively using COM Interop it's not possible to pass binary values to .NET. The reason for this is that FoxPro turns binary data into SAFEARRAY's which have a different .NET type signature (Byte[*]) when they arrive inside of .NET.So if you have a .NET method like:```cspublic byte[] PassBinary(byte[] data){    return data;}```there's no easy way to call it from FoxPro via plain COM Interop. You might think that CAST(lbData as Blob) or CreateBinary(lbData) would do the trick on the VFP end, but it doesn't properly create the byte array .NET expects and so fails with an 'Invalid Parameter' COM exception.Using wwDotNetBridge however, `InvokeMethod()` and `SetProperty(`) automatically intercept type inputs of Byte[*] and convert these values to proper byte[] arrays and so calls using these operations work fine with byte[] array input values. You do need to make sure however that you cast any binary properly to the `Blob` using `CAST(binValue as W)` or `CAST(binValue as BLOB)`.The following example demonstrates how you can pass byte[] data with straight COM Interop:```foxproLOCAL loNet as DotNetCom.DotNetComPublisherloNet = CREATEOBJECT('DotNetCom.DotNetComPublisher') do wwDotNetBridgeLOCAL loBridge as wwDotNetBridgeloBridge = CreateObject("wwDotNetBridge")* ** Create some binary data from a filelcData = FILETOSTR("c:\photos\sailbig.jpg")* THIS DOES NOT WORK:* ? loNet.PassBinary(CAST(lcData as W))* ** Works - wwDotNetBridge automatically converts to byte[]? loBridge.InvokeMethod( loNet,"passBinary",CAST(lcData as W) )* ** This also works? loBridge.InvokeMethod( loNet,"passBinary",CreateBinary(lcData) )```Note that binary values returned FROM .NET work just fine and are received as binary Blob types (Q) in VFP 9.0.